import { BaseComponent } from '../base-component';
import { icons } from '../../lib/icons';
// Import components and types
import '../ui/app-button';
// Import types explicitly
import type { AppButton } from '../ui/app-button';

export class Pagination extends BaseComponent {
    static get observedAttributes() {
        return ['current-page', 'total-pages', 'max-visible'];
    }

    protected get styles(): string {
        return `
            :host {
                display: block;
            }
            nav {
                display: flex;
                justify-content: center;
                align-items: center;
                gap: var(--spacing-1, 0.25rem);
            }
            app-button {
                /* Use icon size for numbers, default for prev/next */
                min-width: 2.25rem; /* Ensure minimum width for icon buttons */
            }
            app-button[data-active="true"] {
                /* Style for active page - using outline variant look */
                 border-color: var(--color-input-border);
                 background-color: var(--color-secondary);
                 color: var(--color-secondary-foreground);
                 /* Ensure hover doesn't override active state visually */
                 pointer-events: none;
            }
            .ellipsis {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 2.25rem; /* Match button size */
                height: 2.25rem;
                color: var(--color-muted-foreground);
            }
            .ellipsis svg {
                 width: 1rem;
                 height: 1rem;
            }
            /* Hide text on small screens for prev/next */
             @media (max-width: 640px) {
                 app-button#prev-button .button-text, app-button#next-button .button-text {
                     display: none;
                 }
                 app-button#prev-button, app-button#next-button {
                     padding-left: var(--spacing-2); /* Adjust padding for icon only */
                     padding-right: var(--spacing-2);
                 }
             }
        `;
    }

    // Implement the abstract template method
    protected get template(): string {
         // The content will be generated by renderPagination()
         // Return an empty string or a placeholder container
         return `<nav role="navigation" aria-label="pagination"></nav>`;
    }


    // Render based on attributes
    connectedCallback() {
        super.connectedCallback(); // Apply styles and initial template
        this.renderPagination(); // Initial render
    }

    attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null) {
        // No need for super call if BaseComponent doesn't implement it
        if (oldValue !== newValue && this.isConnected) {
            this.renderPagination();
        }
    }

    private renderPagination(): void {
        const nav = this.shadowRoot?.querySelector('nav');
        if (!nav) return; // Should not happen if template is correct

        // Clear previous content
        nav.innerHTML = '';

        const currentPage = this.getNumAttribute('current-page') ?? 1;
        const totalPages = this.getNumAttribute('total-pages') ?? 1;
        const maxVisible = this.getNumAttribute('max-visible') ?? 5;

        if (totalPages <= 1) {
            this.style.display = 'none'; // Hide the component itself if not needed
            return;
        } else {
            this.style.display = ''; // Ensure component is visible
        }

        const chevronLeftIcon = icons.chevronLeft ?? '';
        const chevronRightIcon = icons.chevronRight ?? '';
        const moreIcon = icons.moreHorizontal ?? '';

        // Previous Button
        const prevButton = this.createButton(
            'Previous',
            currentPage - 1,
            'prev-button',
            currentPage === 1,
            'default' // Size for Prev/Next
        );
        const leftIconHtml = typeof chevronLeftIcon === 'function' ? chevronLeftIcon() : chevronLeftIcon;
        prevButton.innerHTML = `${leftIconHtml}<span class="button-text sm:inline hidden">Previous</span>`; // Use class to hide text
        nav.appendChild(prevButton);

        // Page Number Buttons & Ellipsis
        const pageNumbers = this.getPageNumbers(currentPage, totalPages, maxVisible);
        pageNumbers.forEach((page) => {
            if (page === '...') {
                const ellipsisSpan = this.createElement('span', {
                    classes: 'ellipsis',
                    attributes: { 'aria-hidden': 'true' },
                    html: typeof moreIcon === 'function' ? moreIcon() : moreIcon // Handle function or string
                });
                nav.appendChild(ellipsisSpan);
            } else {
                const pageButton = this.createButton(
                    `Page ${page}`,
                    page as number, // Type assertion is safe here
                    `page-${page}`,
                    false, // Never disabled
                    'icon' // Size for numbers
                );
                pageButton.textContent = String(page);
                if (page === currentPage) {
                    pageButton.setAttribute('data-active', 'true');
                    pageButton.setAttribute('aria-current', 'page');
                }
                nav.appendChild(pageButton);
            }
        });

        // Next Button
        const nextButton = this.createButton(
            'Next',
            currentPage + 1,
            'next-button',
            currentPage === totalPages,
            'default' // Size for Prev/Next
        );
        const rightIconHtml = typeof chevronRightIcon === 'function' ? chevronRightIcon() : chevronRightIcon;
        nextButton.innerHTML = `<span class="button-text sm:inline hidden">Next</span>${rightIconHtml}`; // Use class to hide text
        nav.appendChild(nextButton);
    }

    private createButton(
        label: string,
        page: number,
        id: string,
        isDisabled: boolean,
        size: 'default' | 'icon' = 'icon'
    ): AppButton {
        // Use imported type
        const button = this.createElement('app-button') as AppButton; // Use helper
        button.setAttribute('variant', 'ghost');
        button.setAttribute('size', size);
        button.setAttribute('aria-label', `Go to ${label.toLowerCase()} page`);
        button.id = id;
        if (isDisabled) {
            button.setAttribute('disabled', '');
            button.setAttribute('aria-disabled', 'true');
        } else {
            button.addEventListener('click', () => this.handlePageChange(page));
        }
        // Content (including icon) is set in renderPagination
        return button;
    }

    private handlePageChange(page: number): void {
         const currentPage = this.getNumAttribute('current-page') ?? 1;
         if (page !== currentPage) {
            this.dispatchEvent(new CustomEvent('pagechange', {
                detail: { page },
                bubbles: true,
                composed: true
            }));
            // The parent component should update the 'current-page' attribute
            // which will trigger attributeChangedCallback and re-render.
         }
    }

     // --- Logic to determine which page numbers to display ---
     private getPageNumbers(currentPage: number, totalPages: number, maxVisiblePages: number): (number | '...')[] {
        const pages: (number | '...')[] = [];
        if (totalPages <= maxVisiblePages) {
            for (let i = 1; i <= totalPages; i++) pages.push(i);
        } else {
            const pagesToShow = maxVisiblePages - 2; // Minus first and last page slots
            const sidePages = Math.floor(pagesToShow / 2);
            const extraPage = pagesToShow % 2;

            let startPage = Math.max(2, currentPage - sidePages);
            let endPage = Math.min(totalPages - 1, currentPage + sidePages + extraPage);

            // Adjust if near the start
            if (currentPage - sidePages <= 2) {
                 endPage = Math.min(totalPages - 1, 1 + pagesToShow);
                 startPage = 2;
            }
            // Adjust if near the end
            else if (currentPage + sidePages + extraPage >= totalPages - 1) {
                 startPage = Math.max(2, totalPages - pagesToShow);
                 endPage = totalPages - 1;
            }

            pages.push(1); // Always show first page
            if (startPage > 2) pages.push('...'); // Ellipsis before middle section
            for (let i = startPage; i <= endPage; i++) pages.push(i);
            if (endPage < totalPages - 1) pages.push('...'); // Ellipsis after middle section
            pages.push(totalPages); // Always show last page
        }
        return pages;
    }
}

// Define the component unless already defined
if (!customElements.get('app-pagination')) {
    customElements.define('app-pagination', Pagination);
}
