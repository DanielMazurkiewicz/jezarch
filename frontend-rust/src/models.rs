use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use strum_macros::{Display, EnumIter}; // Import EnumIter derive macro

// --- Auth & User ---
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default, Copy)]
pub enum UserRole { #[serde(rename = "admin")] Admin, #[default] #[serde(rename = "regular_user")] RegularUser }
#[derive(Debug, Clone, Serialize, Deserialize)] #[serde(rename_all = "camelCase")] pub struct User { pub user_id: Option<i64>, pub login: String, #[serde(skip_serializing_if = "Option::is_none")] pub password: Option<String>, #[serde(default)] pub role: Option<UserRole>, #[serde(skip_serializing_if = "Option::is_none")] pub created_on: Option<DateTime<Utc>>, #[serde(skip_serializing_if = "Option::is_none")] pub modified_on: Option<DateTime<Utc>> } // Made IDs/dates optional to match GET response
#[derive(Debug, Clone, Serialize, Deserialize, Default)] #[serde(rename_all = "camelCase")] pub struct UserInfo { pub user_id: Option<i64>, pub login: String, pub role: Option<UserRole> }
#[derive(Debug, Clone, Serialize, Deserialize)] #[serde(rename_all = "camelCase")] pub struct UserCredentials { pub login: String, pub password: String }
#[derive(Debug, Clone, Serialize, Deserialize, Default)] #[serde(rename_all = "camelCase")] // Added Default
pub struct AuthResponse { pub token: String, pub login: String, pub role: Option<UserRole>, pub user_id: Option<i64> }

// --- Tag ---
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash, Default)] #[serde(rename_all = "camelCase")]
pub struct Tag { #[serde(skip_serializing_if = "Option::is_none")] pub tag_id: Option<i64>, pub name: String, #[serde(skip_serializing_if = "Option::is_none")] pub description: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub created_on: Option<DateTime<Utc>>, #[serde(skip_serializing_if = "Option::is_none")] pub modified_on: Option<DateTime<Utc>> }
pub type TagInput = PickTagCreateUpdate;
#[derive(Debug, Clone, Serialize)] #[serde(rename_all = "camelCase")] pub struct PickTagCreateUpdate { pub name: String, #[serde(skip_serializing_if = "Option::is_none")] pub description: Option<String> }

// --- Note ---
#[derive(Debug, Clone, Serialize, Deserialize, Default)] #[serde(rename_all = "camelCase")]
pub struct Note { #[serde(skip_serializing_if = "Option::is_none")] pub note_id: Option<i64>, #[serde(default)] pub owner_user_id: i64, pub title: String, pub content: Option<String>, #[serde(default)] pub shared: bool, #[serde(default = "Utc::now")] pub created_on: DateTime<Utc>, #[serde(default = "Utc::now")] pub modified_on: DateTime<Utc> }
#[derive(Debug, Clone, Serialize, Deserialize, Default)] #[serde(rename_all = "camelCase")]
pub struct NoteWithDetails { #[serde(flatten)] pub note: Note, #[serde(default)] pub tags: Vec<Tag>, #[serde(skip_serializing_if = "Option::is_none")] pub owner_login: Option<String> }
#[derive(Debug, Clone, Serialize, Deserialize)] #[serde(rename_all = "camelCase")]
pub struct NoteInput { pub title: String, #[serde(skip_serializing_if = "Option::is_none")] pub content: Option<String>, pub shared: bool, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub tag_ids: Vec<i64> }

// --- Signature Component ---
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Default, EnumIter, Display)] // Added EnumIter, Display
#[serde(rename_all = "snake_case")] pub enum SignatureComponentIndexType { #[default] Dec, Roman, SmallChar, CapitalChar }
#[derive(Debug, Clone, Serialize, Deserialize, Default)] #[serde(rename_all = "camelCase")] pub struct SignatureComponent { #[serde(skip_serializing_if = "Option::is_none")] pub signature_component_id: Option<i64>, pub name: String, #[serde(skip_serializing_if = "Option::is_none")] pub description: Option<String>, #[serde(default)] pub index_type: SignatureComponentIndexType, #[serde(skip_serializing_if = "Option::is_none")] pub index_count: Option<i32>, #[serde(skip_serializing_if = "Option::is_none")] pub created_on: Option<DateTime<Utc>>, #[serde(skip_serializing_if = "Option::is_none")] pub modified_on: Option<DateTime<Utc>> }
#[derive(Debug, Clone, Serialize)] #[serde(rename_all = "camelCase")] pub struct CreateSignatureComponentInput { pub name: String, #[serde(skip_serializing_if = "Option::is_none")] pub description: Option<String>, pub index_type: SignatureComponentIndexType }
#[derive(Debug, Clone, Serialize, Default)] #[serde(rename_all = "camelCase")] pub struct UpdateSignatureComponentInput { #[serde(skip_serializing_if = "Option::is_none")] pub name: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub description: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub index_type: Option<SignatureComponentIndexType> }

// --- Signature Element ---
#[derive(Debug, Clone, Serialize, Deserialize, Default)] #[serde(rename_all = "camelCase")] pub struct SignatureElement { #[serde(skip_serializing_if = "Option::is_none")] pub signature_element_id: Option<i64>, #[serde(default)] pub signature_component_id: i64, pub name: String, #[serde(skip_serializing_if = "Option::is_none")] pub description: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub index: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub created_on: Option<DateTime<Utc>>, #[serde(skip_serializing_if = "Option::is_none")] pub modified_on: Option<DateTime<Utc>>, #[serde(skip_serializing_if = "Option::is_none")] pub component: Option<Box<SignatureComponent>>, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub parent_elements: Vec<SignatureElement> }
#[derive(Debug, Clone, Serialize, Deserialize)] #[serde(rename_all = "camelCase")] pub struct SignatureElementSearchResult { #[serde(flatten)] pub element: SignatureElement, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub resolved_topographic_signatures: Vec<String>, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub resolved_descriptive_signatures: Vec<String> }
#[derive(Debug, Clone, Serialize)] #[serde(rename_all = "camelCase")] pub struct CreateSignatureElementInput { pub signature_component_id: i64, pub name: String, #[serde(skip_serializing_if = "Option::is_none")] pub description: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub index: Option<String>, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub parent_ids: Vec<i64> }
#[derive(Debug, Clone, Serialize, Default)] #[serde(rename_all = "camelCase")] pub struct UpdateSignatureElementInput { #[serde(skip_serializing_if = "Option::is_none")] pub name: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub description: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub index: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub parent_ids: Option<Vec<i64>> }

// --- Archive Document ---
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Default, Display)] // Add Display
#[serde(rename_all = "snake_case")] pub enum ArchiveDocumentType { Unit, #[default] Document }
#[derive(Debug, Clone, Serialize, Deserialize, Default)] #[serde(rename_all = "camelCase")]
pub struct ArchiveDocument { #[serde(skip_serializing_if = "Option::is_none")] pub archive_document_id: Option<i64>, #[serde(skip_serializing_if = "Option::is_none")] pub parent_unit_archive_document_id: Option<i64>, #[serde(default)] pub owner_user_id: i64, #[serde(rename = "type", default)] pub doc_type: ArchiveDocumentType, pub title: String, pub creator: String, #[serde(default)] pub creation_date: String, #[serde(skip_serializing_if = "Option::is_none")] pub number_of_pages: Option<i32>, #[serde(skip_serializing_if = "Option::is_none")] pub document_type: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub dimensions: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub binding: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub condition: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub document_language: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub content_description: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub remarks: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub access_level: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub access_conditions: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub additional_information: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub related_documents_references: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub is_digitized: Option<bool>, #[serde(skip_serializing_if = "Option::is_none")] pub digitized_version_link: Option<String>, #[serde(default)] pub active: bool, #[serde(skip_serializing_if = "Option::is_none")] pub created_on: Option<DateTime<Utc>>, #[serde(skip_serializing_if = "Option::is_none")] pub modified_on: Option<DateTime<Utc>>, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub tags: Vec<Tag>, #[serde(skip_serializing_if = "Option::is_none")] pub owner_login: Option<String>, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub topographic_signature_element_ids: Vec<Vec<i64>>, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub descriptive_signature_element_ids: Vec<Vec<i64>> }
#[derive(Debug, Clone, Serialize, Deserialize)] #[serde(rename_all = "camelCase")] pub struct ArchiveDocumentSearchResult { #[serde(flatten)] pub document: ArchiveDocument, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub resolved_topographic_signatures: Vec<String>, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub resolved_descriptive_signatures: Vec<String> }

// --- Archive Document Input Types ---
#[derive(Debug, Clone, Serialize)] #[serde(rename_all = "camelCase")] pub struct CreateArchiveDocumentInput { #[serde(rename = "type")] pub doc_type: ArchiveDocumentType, pub title: String, pub creator: String, pub creation_date: String, #[serde(skip_serializing_if = "Option::is_none")] pub parent_unit_archive_document_id: Option<i64>, #[serde(skip_serializing_if = "Option::is_none")] pub number_of_pages: Option<i32>, #[serde(skip_serializing_if = "Option::is_none")] pub document_type: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub dimensions: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub binding: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub condition: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub document_language: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub content_description: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub access_level: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub access_conditions: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub is_digitized: Option<bool>, #[serde(skip_serializing_if = "Option::is_none")] pub remarks: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub additional_information: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub related_documents_references: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub digitized_version_link: Option<String>, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub tag_ids: Vec<i64>, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub topographic_signature_element_ids: Vec<Vec<i64>>, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub descriptive_signature_element_ids: Vec<Vec<i64>> }
#[derive(Debug, Clone, Serialize, Default)] #[serde(rename_all = "camelCase")] pub struct UpdateArchiveDocumentInput { #[serde(skip_serializing_if = "Option::is_none")] pub parent_unit_archive_document_id: Option<Option<i64>>, #[serde(skip_serializing_if = "Option::is_none")] pub title: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub creator: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub creation_date: Option<String>, #[serde(skip_serializing_if = "Option::is_none")] pub number_of_pages: Option<Option<i32>>, #[serde(skip_serializing_if = "Option::is_none")] pub document_type: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub dimensions: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub binding: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub condition: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub document_language: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub content_description: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub remarks: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub access_level: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub access_conditions: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub additional_information: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub related_documents_references: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub is_digitized: Option<bool>, #[serde(skip_serializing_if = "Option::is_none")] pub digitized_version_link: Option<Option<String>>, #[serde(skip_serializing_if = "Option::is_none")] pub tag_ids: Option<Vec<i64>>, #[serde(skip_serializing_if = "Option::is_none")] pub topographic_signature_element_ids: Option<Vec<Vec<i64>>>, #[serde(skip_serializing_if = "Option::is_none")] pub descriptive_signature_element_ids: Option<Vec<Vec<i64>>>, #[serde(skip_serializing_if = "Option::is_none")] pub active: Option<bool> }


// --- Admin & Config ---
#[derive(Debug, Clone, Serialize, Deserialize, Default)] #[serde(rename_all = "camelCase")] pub struct AppConfig { pub port: Option<String>, pub default_language: Option<String> }
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash, Display)] // Added Display
#[serde(rename_all = "SCREAMING_SNAKE_CASE")] pub enum AppConfigKey { Port, DefaultLanguage }
#[derive(Debug, Clone, Serialize, Deserialize)] #[serde(rename_all = "camelCase")] pub struct SslConfig { pub key: String, pub cert: String }
#[derive(Debug, Clone, Serialize, Deserialize, Default)] #[serde(rename_all = "camelCase")] pub struct LogEntry { #[serde(default)] pub id: i64, #[serde(default)] pub level: String, #[serde(skip_serializing_if = "Option::is_none")] pub user_id: Option<i64>, #[serde(skip_serializing_if = "Option::is_none")] pub category: Option<String>, #[serde(default)] pub message: String, #[serde(skip_serializing_if = "Option::is_none")] pub data: Option<String>, #[serde(default = "Utc::now")] pub created_on: DateTime<Utc> }

// --- Search ---
#[derive(Debug, Clone, Serialize, Deserialize)] #[serde(rename_all = "camelCase")] pub struct SearchQueryElement { pub field: String, pub condition: SearchCondition, pub value: serde_json::Value, #[serde(default)] pub not: bool }
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)] #[serde(rename_all = "SCREAMING_SNAKE_CASE")] pub enum SearchCondition { Eq, Fragment, Gt, Gte, Lt, Lte, AnyOf, HasParents }
#[derive(Debug, Clone, Serialize, Deserialize, Default)] #[serde(rename_all = "camelCase")] // Add Default
pub struct SortElement { pub field: String, #[serde(default)] pub direction: SortDirection }
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)] #[serde(rename_all = "SCREAMING_SNAKE_CASE")] pub enum SortDirection { #[default] Asc, Desc }
#[derive(Debug, Clone, Serialize, Deserialize, Default)] #[serde(rename_all = "camelCase")] // Add Default
pub struct SearchRequest { #[serde(default, skip_serializing_if = "Vec::is_empty")] pub query: Vec<SearchQueryElement>, #[serde(default = "default_page")] pub page: usize, #[serde(default = "default_page_size")] pub page_size: usize, #[serde(default, skip_serializing_if = "Vec::is_empty")] pub sort: Vec<SortElement> }
fn default_page() -> usize { 1 }
fn default_page_size() -> usize { 10 }
#[derive(Debug, Clone, Serialize, Deserialize)] #[serde(rename_all = "camelCase")] pub struct SearchResponse<T> { pub data: Vec<T>, pub page: usize, pub page_size: usize, pub total_pages: usize, pub total_size: usize }
impl<T> Default for SearchResponse<T> { fn default() -> Self { Self { data: Vec::new(), page: 1, page_size: 0, total_pages: 1, total_size: 0 } } }